





from DeepJetCore.TrainData import TrainData, fileTimeOut
import numpy 

class TrainData_example(TrainData):
    def __init__(self):
        TrainData.__init__(self)

        self.treename="tree" #input root tree name
        
        self.truthclasses=['isA','isB','isC'] #truth classes for classification
        
        self.weightbranchX='isA' #needs to be specified if weighter is used
        self.weightbranchY='isB' #needs to be specified if weighter is used
        
        #there is no need to resample/reweight
        self.weight=False
        self.remove=False
        #does not do anything in this configuration
        self.referenceclass='flatten'
        self.weight_binX = numpy.array([0,40000],dtype=float) 
        self.weight_binY = numpy.array([0,40000],dtype=float) 
        
        
        self.registerBranches(['']) #list of branches to be used 
        
        #means norms are only produced for branches that are registered (for performance reasons)
        self.registerBranches(self.truthclasses)
        
        
        #call this at the end
        self.reduceTruth(None)
        
    
    def readFromRootFile(self,filename,TupleMeanStd, weighter):
    
        # this function defines how to convert the root ntuple to the training format
        # options are not yet described here
        
        import ROOT
        fileTimeOut(filename,120) #give eos a minute to recover
        rfile = ROOT.TFile(filename)
        tree = rfile.Get("tree")
        self.nsamples=tree.GetEntries()
        
        
        # user code, example works with the example 2D images in root format generated by make_example_data
        from DeepJetCore.preprocessing import read2DArray
        print(filename)
        feature_array = read2DArray(filename,"tree","image2d",self.nsamples,32,32)
        
        print('feature_array',feature_array.shape)
        truth = self.read_truthclasses(filename)
        
        #notremoves=weighter.createNotRemoveIndices(Tuple)
        
        # this removes parts of the dataset for weighting the events
        #feature_array = feature_array[notremoves > 0]
                
        # call this in the end
        
        self.nsamples=len(feature_array)
        
        self.x=[feature_array] # list of feature numpy arrays
        self.y=[truth] # list of target numpy arrays (truth)
        self.w=[] # list of weight arrays. One for each truth target, not used


    def formatPrediction(self, predicted_list):
        
        format_names = ['prob_isA','prob_isB','prob_isC']
        out_pred = [predicted_list[0][:,0],predicted_list[0][:,1],predicted_list[0][:,2]]
        
        return out_pred,  format_names

class TrainData_example_reg(TrainData):
    def __init__(self):
        TrainData.__init__(self)

        self.treename="tree" #input root tree name
        
        self.truthclasses=[]#['isA','isB','isC'] #truth classes for classification
        self.regressiontargetclasses=['sigsum']
        
        self.weightbranchX='isA' #needs to be specified if weighter is used
        self.weightbranchY='isB' #needs to be specified if weighter is used
        
        #there is no need to resample/reweight
        self.weight=False
        self.remove=False
        #does not do anything in this configuration
        self.referenceclass='flatten'
        self.weight_binX = numpy.array([0,40000],dtype=float) 
        self.weight_binY = numpy.array([0,40000],dtype=float) 
        
        
        self.registerBranches(self.regressiontargetclasses) #list of branches to be used 
        
        self.registerBranches(self.truthclasses)
        
        
        #call this at the end
        self.reduceTruth(None)
        
    
    def readFromRootFile(self,filename,TupleMeanStd, weighter):
    
        # this function defines how to convert the root ntuple to the training format
        # options are not yet described here
        
        import ROOT
        fileTimeOut(filename,120) #give eos a minute to recover
        rfile = ROOT.TFile(filename)
        tree = rfile.Get("tree")
        self.nsamples=tree.GetEntries()
        
        
        # user code, example works with the example 2D images in root format generated by make_example_data
        from DeepJetCore.preprocessing import read2DArray
        print(filename)
        feature_array = read2DArray(filename,"tree","image2d",self.nsamples,32,32)
        
        npy_array = self.readTreeFromRootToTuple(filename)
        reg_truth = npy_array['sigsum']
        
        #notremoves=weighter.createNotRemoveIndices(Tuple)
        
        # this removes parts of the dataset for weighting the events
        #feature_array = feature_array[notremoves > 0]
                
        # call this in the end
        
        self.nsamples=len(feature_array)
        
        self.x=[feature_array] # list of feature numpy arrays
        self.y=[reg_truth] # list of target numpy arrays (truth)
        self.w=[] # list of weight arrays. One for each truth target, not used

    def formatPrediction(self, predicted_list):
        
        format_names = ['sigsum']
        out_pred = predicted_list
        
        return out_pred,  format_names
    

class TrainData_example_frac(TrainData):
    def __init__(self):
        TrainData.__init__(self)

        self.treename="tree" #input root tree name
        
        self.truthclasses=[]#['isA','isB','isC'] #truth classes for classification
        self.regressiontargetclasses=['sigfrac_bgfrac_featforweights']
        
        self.weightbranchX='isA' #needs to be specified if weighter is used
        self.weightbranchY='isB' #needs to be specified if weighter is used
        
        #there is no need to resample/reweight
        self.weight=False
        self.remove=False
        #does not do anything in this configuration
        self.referenceclass='flatten'
        self.weight_binX = numpy.array([0,40000],dtype=float) 
        self.weight_binY = numpy.array([0,40000],dtype=float) 
        
        
        #self.registerBranches() #list of branches to be used 
        
        self.registerBranches(self.truthclasses)
        
        
        #call this at the end
        self.reduceTruth(None)
        
    
    def readFromRootFile(self,filename,TupleMeanStd, weighter):
    
        # this function defines how to convert the root ntuple to the training format
        # options are not yet described here
        import numpy as np
        import ROOT
        fileTimeOut(filename,120) #give eos a minute to recover
        rfile = ROOT.TFile(filename)
        tree = rfile.Get("tree")
        self.nsamples=tree.GetEntries()
        
        
        # user code, example works with the example 2D images in root format generated by make_example_data
        from DeepJetCore.preprocessing import read2DArray
        print(filename)
        feature_array = read2DArray(filename,"tree","image2d",self.nsamples,32,32)
        
        reg_truth = read2DArray(filename,"tree","sigfrac2d",self.nsamples,32,32)
        bgfrac = 1 - reg_truth
        
        truth = np.concatenate([reg_truth, bgfrac, feature_array], axis=-1)
        
        #notremoves=weighter.createNotRemoveIndices(Tuple)
        
        # this removes parts of the dataset for weighting the events
        #feature_array = feature_array[notremoves > 0]
                
        # call this in the end
        
        self.nsamples=len(feature_array)
        
        self.x=[feature_array] # list of feature numpy arrays
        self.y=[truth] # list of target numpy arrays (truth)
        self.w=[] # list of weight arrays. One for each truth target, not used


    def formatPrediction(self, predicted_list):
        
        format_names = ['sigfrac','bgfrac']
        out_pred = [predicted_list[0][:,:,1],predicted_list[0][:,:,2]]
        
        return out_pred,  format_names

